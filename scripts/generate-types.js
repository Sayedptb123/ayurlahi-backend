#!/usr/bin/env node

/**
 * Generate TypeScript types from OpenAPI specification
 * This script reads the OpenAPI spec and generates TypeScript types
 * that can be used in the frontend to ensure type safety.
 */

const fs = require('fs');
const path = require('path');

const OPENAPI_SPEC_PATH = path.join(__dirname, '..', 'api-spec', 'openapi.json');
const OUTPUT_DIR = path.join(__dirname, '..', 'shared', 'types');
const OUTPUT_FILE = path.join(OUTPUT_DIR, 'api-types.ts');

function generateTypes() {
  console.log('ðŸ” Generating TypeScript types from OpenAPI spec...');

  // Check if OpenAPI spec exists
  if (!fs.existsSync(OPENAPI_SPEC_PATH)) {
    console.error('âŒ OpenAPI spec not found. Please run the backend server first to generate it.');
    console.error(`   Expected location: ${OPENAPI_SPEC_PATH}`);
    process.exit(1);
  }

  // Read OpenAPI spec
  const spec = JSON.parse(fs.readFileSync(OPENAPI_SPEC_PATH, 'utf-8'));

  // Create output directory
  if (!fs.existsSync(OUTPUT_DIR)) {
    fs.mkdirSync(OUTPUT_DIR, { recursive: true });
  }

  // Generate types
  let typesCode = `/**
 * Auto-generated TypeScript types from OpenAPI specification
 * DO NOT EDIT THIS FILE MANUALLY
 * Generated at: ${new Date().toISOString()}
 * 
 * To regenerate: npm run generate:types
 */

`;

  // Generate types from schemas
  if (spec.components && spec.components.schemas) {
    typesCode += generateTypesFromSchemas(spec.components.schemas);
  }

  // Generate API endpoint types
  if (spec.paths) {
    typesCode += generateEndpointTypes(spec.paths);
  }

  // Write to file
  fs.writeFileSync(OUTPUT_FILE, typesCode);
  console.log(`âœ… Types generated successfully: ${OUTPUT_FILE}`);
  console.log(`   Total types: ${Object.keys(spec.components?.schemas || {}).length}`);
}

function generateTypesFromSchemas(schemas) {
  let code = '\n// ============================================\n';
  code += '// Schema Types\n';
  code += '// ============================================\n\n';

  for (const [name, schema] of Object.entries(schemas)) {
    code += generateTypeFromSchema(name, schema);
    code += '\n';
  }

  return code;
}

function generateTypeFromSchema(name, schema) {
  if (schema.type === 'object' && schema.properties) {
    let code = `export interface ${name} {\n`;
    
    for (const [propName, propSchema] of Object.entries(schema.properties)) {
      const required = schema.required?.includes(propName) ? '' : '?';
      const type = mapOpenAPITypeToTS(propSchema);
      code += `  ${propName}${required}: ${type};\n`;
    }
    
    code += '}\n';
    return code;
  } else if (schema.type === 'array' && schema.items) {
    const itemType = mapOpenAPITypeToTS(schema.items);
    return `export type ${name} = ${itemType}[];\n`;
  } else {
    const type = mapOpenAPITypeToTS(schema);
    return `export type ${name} = ${type};\n`;
  }
}

function mapOpenAPITypeToTS(schema) {
  if (schema.$ref) {
    // Extract type name from $ref
    const refName = schema.$ref.split('/').pop();
    return refName;
  }

  if (schema.type === 'string') {
    if (schema.enum) {
      return schema.enum.map(e => `'${e}'`).join(' | ');
    }
    if (schema.format === 'date-time' || schema.format === 'date') {
      return 'string'; // ISO 8601 string
    }
    return 'string';
  }

  if (schema.type === 'number' || schema.type === 'integer') {
    return 'number';
  }

  if (schema.type === 'boolean') {
    return 'boolean';
  }

  if (schema.type === 'array') {
    const itemType = mapOpenAPITypeToTS(schema.items);
    return `${itemType}[]`;
  }

  if (schema.type === 'object') {
    if (schema.properties) {
      // Inline object type
      let code = '{\n';
      for (const [propName, propSchema] of Object.entries(schema.properties)) {
        const required = schema.required?.includes(propName) ? '' : '?';
        const type = mapOpenAPITypeToTS(propSchema);
        code += `    ${propName}${required}: ${type};\n`;
      }
      code += '  }';
      return code;
    }
    return 'Record<string, any>';
  }

  return 'any';
}

function generateEndpointTypes(paths) {
  let code = '\n// ============================================\n';
  code += '// API Endpoint Types\n';
  code += '// ============================================\n\n';

  for (const [path, methods] of Object.entries(paths)) {
    for (const [method, operation] of Object.entries(methods)) {
      if (method === 'parameters') continue;

      const operationId = operation.operationId || `${method}_${path.replace(/\//g, '_')}`;
      
      // Request body type
      if (operation.requestBody) {
        const requestBody = operation.requestBody.content?.['application/json']?.schema;
        if (requestBody) {
          const requestType = mapOpenAPITypeToTS(requestBody);
          code += `export type ${operationId}Request = ${requestType};\n`;
        }
      }

      // Response types
      if (operation.responses) {
        for (const [statusCode, response] of Object.entries(operation.responses)) {
          if (response.content?.['application/json']?.schema) {
            const responseType = mapOpenAPITypeToTS(response.content['application/json'].schema);
            const statusName = statusCode === '200' ? 'Success' : statusCode === '201' ? 'Created' : `Status${statusCode}`;
            code += `export type ${operationId}${statusName}Response = ${responseType};\n`;
          }
        }
      }
    }
  }

  return code;
}

// Run if called directly
if (require.main === module) {
  generateTypes();
}

module.exports = { generateTypes };


